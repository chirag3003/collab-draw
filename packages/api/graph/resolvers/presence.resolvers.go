package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"crypto/md5"
	"fmt"
	"time"

	"github.com/chirag3003/collab-draw-backend/graph/model"
	"github.com/chirag3003/collab-draw-backend/internal/auth"
)

// UpdateCursor is the resolver for the updateCursor field.
func (r *mutationResolver) UpdateCursor(ctx context.Context, projectID string, cursor model.CursorInput) (bool, error) {
	authContext := auth.ForContext(ctx)

	// Generate a deterministic color from userID
	color := userIDToColor(authContext.Sub)

	cursorUpdate := &model.CursorUpdate{
		UserID:             authContext.Sub,
		UserName:           authContext.PreferredUsername,
		Color:              color,
		X:                  cursor.X,
		Y:                  cursor.Y,
		SelectedElementIds: cursor.SelectedElementIds,
		Timestamp:          time.Now().Format(time.RFC3339Nano),
	}

	// Broadcast to all cursor subscribers (no DB write)
	r.broadcastCursor(projectID, cursorUpdate, "")
	return true, nil
}

// Cursors is the resolver for the cursors field.
func (r *subscriptionResolver) Cursors(ctx context.Context, projectID string) (<-chan *model.CursorUpdate, error) {
	authContext := auth.ForContext(ctx)

	// Verify user has access
	project, err := r.Repo.Project.GetProjectByID(ctx, projectID, authContext.Sub)
	if err != nil || project == nil {
		return nil, fmt.Errorf("project not found or access denied")
	}

	ch := make(chan *model.CursorUpdate, 64)
	socketID := r.subscribeToCursors(projectID, ch)

	go func(socketID string) {
		<-ctx.Done()
		r.unsubscribeFromCursors(projectID, socketID)
	}(socketID)

	return ch, nil
}

// Presence is the resolver for the presence field.
func (r *subscriptionResolver) Presence(ctx context.Context, projectID string) (<-chan []*model.UserPresence, error) {
	authContext := auth.ForContext(ctx)

	// Verify user has access
	project, err := r.Repo.Project.GetProjectByID(ctx, projectID, authContext.Sub)
	if err != nil || project == nil {
		return nil, fmt.Errorf("project not found or access denied")
	}

	ch := make(chan []*model.UserPresence, 16)
	socketID := r.subscribeToPresence(projectID, ch)

	// Send initial presence list
	presenceList := r.getPresenceList(projectID)
	ch <- presenceList

	go func(socketID string) {
		<-ctx.Done()
		r.unsubscribeFromPresence(projectID, socketID)
	}(socketID)

	return ch, nil
}

// userIDToColor generates a deterministic HSL color from a user ID
func userIDToColor(userID string) string {
	hash := md5.Sum([]byte(userID))
	hue := int(hash[0])<<8 | int(hash[1])
	return fmt.Sprintf("hsl(%d, 70%%, 50%%)", hue%360)
}
